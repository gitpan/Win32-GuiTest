<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Win32::GuiTest - Perl GUI Test Utilities.</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#installation">INSTALLATION</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#functions">Functions</a></li>
		<li><a href="#dibsect">DibSect</a></li>
	</ul>

	<li><a href="#development">DEVELOPMENT</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#todo">TODO</a></li>
	<ul>

		<li><a href="#perl_only">Perl only</a></li>
		<li><a href="#c++_compiler_needed">C++ compiler needed</a></li>
	</ul>

	<li><a href="#version">VERSION</a></li>
	<li><a href="#changes">CHANGES</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<li><a href="#authors">AUTHORS</a></li>
	<li><a href="#credits">CREDITS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Win32::GuiTest - Perl GUI Test Utilities.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Win32::GuiTest qw(FindWindowLike GetWindowText 
    SetForegroundWindow SendKeys);</pre>
<pre>
  $Win32::GuiTest::debug = 0; # Set to &quot;1&quot; to enable verbose mode</pre>
<pre>
  my @windows = FindWindowLike(0, &quot;^Microsoft Excel&quot;, &quot;^XLMAIN\$&quot;);
  for (@windows) {
      print &quot;$_&gt;\t'&quot;, GetWindowText($_), &quot;'\n&quot;;
      SetForegroundWindow($_);
      SendKeys(&quot;%fn~a{TAB}b{TAB}{BS}{DOWN}&quot;);
  }</pre>
<p>
</p>
<hr />
<h1><a name="installation">INSTALLATION</a></h1>
<pre>
    // This batch file comes with MS Visual Studio.  Running
    // it first might help with various compilation problems.
    vcvars32.bat</pre>
<pre>
    perl makefile.pl
    nmake
    nmake test
    nmake install</pre>
<pre>
    See more details in the DEVELOPMENT section elswhere in this document.</pre>
<p>You can get the most recent release from 
<a href="http://www.sourceforge.net/projects/winguitest">http://www.sourceforge.net/projects/winguitest</a>. The package will
contain Win32-GuiTest.ppd file and Win32-GuiTest.tar.gz file, 
which is all that you need to use
ppm. If you put those 2 files in C:\TEMP directory, the installation
should look as follows.  Enter PPM (Perl Package Manager) from the 
command-line and type commands as below</p>
<pre>
    C:\TEMP&gt;ppm
    PPM interactive shell (2.0) - type 'help' for available commands.
    PPM&gt; install C:\temp\win32-guitest.ppd
    Install package 'C:\temp\win32-guitest.ppd?' (y/N): Y
    Retrieving package 'C:\temp\win32-guitest.ppd'...
    Writing C:\Perl\site\lib\auto\Win32\GuiTest\.packlist
    PPM&gt;</pre>
<p>I extracted them to 'c:\temp', please use the directory where you extracted 
the files instead.</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Most GUI test scripts I have seen/written for Win32 use some variant of Visual
Basic (e.g. MS-VB or MS-Visual Test). The main reason is the availability of
the SendKeys function.</p>
<p>A nice way to drive Win32 programs from a test script is to use OLE Automation
(ActiveX Scripting), but not all Win32 programs support this interface. That is
where SendKeys comes handy.</p>
<p>Some time ago Al Williams published a Delphi version in Dr. Dobb's
(http://www.ddj.com/ddj/1997/careers1/wil2.htm). I ported it to C and
packaged it using h2xs...</p>
<p>The tentative name for this module is Win32::GuiTest (mostly because I plan to
include more GUI testing functions).</p>
<p>I've created a Yahoo Group for the module that you can join at
   <a href="http://groups.yahoo.com/group/perlguitest/join">http://groups.yahoo.com/group/perlguitest/join</a></p>
<p>Also, an initial version of a script recording application has been written to use with this 
module.  A copy of it may be found with this distribution (Recorder\Win32GuiTest.exe)
or can be obtained at <a href="http://sourceforge.net/projects/winguitest">http://sourceforge.net/projects/winguitest</a></p>
<p>If the documentation of these functions is not satisfactory, you can 
try running a search on <a href="http://msdn.microsoft.com/">http://msdn.microsoft.com/</a> using the name of the function. 
Some of these functions are described there.</p>
<p>This distribution of the module - the one you are looking at now - has
its own CVS repository at <a href="http://sourceforge.net/projects/winguitest">http://sourceforge.net/projects/winguitest</a>
Patches to both the code and the documentation are welcome.</p>
<p>
</p>
<h2><a name="functions">Functions</a></h2>
<dl>
<dt><strong><a name="item_%24debug">$debug</a></strong><br />
</dt>
<dd>
When set enables the verbose mode.
</dd>
<p></p>
<dt><strong><a name="item_sendkeys"><code>SendKeys($keys[,$delay])</code></a></strong><br />
</dt>
<dd>
Sends keystrokes to the active window as if typed at the keyboard using the
optional delay between keystrokes (default is 50 ms and should be OK for
most uses).
</dd>
<dd>
<p>The keystrokes to send are specified in KEYS. There are several
characters that have special meaning. This allows sending control codes 
and modifiers:</p>
</dd>
<dd>
<pre>
        ~ means ENTER
        + means SHIFT 
        ^ means CTRL 
        % means ALT</pre>
</dd>
<dd>
<p>The parens allow character grouping. You may group several characters, so
that a specific keyboard modifier applies to all of them.</p>
</dd>
<dd>
<p>E.g. <a href="#item_sendkeys"><code>SendKeys(``ABC'')</code></a> is equivalent to <a href="#item_sendkeys"><code>SendKeys(``+(abc)'')</code></a></p>
</dd>
<dd>
<p>The curly braces are used to quote special characters (SendKeys(``{+}{{}'')
sends a '+' and a '{'). You can also use them to specify certain named actions:</p>
</dd>
<dd>
<pre>
        Name          Action</pre>
</dd>
<dd>
<pre>
        {BACKSPACE}   Backspace
        {BS}          Backspace
        {BKSP}        Backspace
        {BREAK}       Break
        {CAPS}        Caps Lock
        {DELETE}      Delete
        {DOWN}        Down arrow
        {END}         End
        {ENTER}       Enter (same as ~)
        {ESCAPE}      Escape
        {HELP}        Help key
        {HOME}        Home
        {INSERT}      Insert
        {LEFT}        Left arrow
        {NUMLOCK}     Num lock
        {PGDN}        Page down
        {PGUP}        Page up
        {PRTSCR}      Print screen
        {RIGHT}       Right arrow
        {SCROLL}      Scroll lock
        {TAB}         Tab
        {UP}          Up arrow
        {PAUSE}       Pause
        {F1}          Function Key 1
        ...           ...
        {F24}         Function Key 24
        {SPC}         Spacebar
        {SPACE}       Spacebar
        {SPACEBAR}    Spacebar
        {LWI}         Left Windows Key
        {RWI}         Right Windows Key 
        {APP}         Open Context Menu Key</pre>
</dd>
<dd>
<p>All these named actions take an optional integer argument, like in {RIGHT 5}. 
For all of them, except PAUSE, the argument means a repeat count. For PAUSE
it means the number of milliseconds SendKeys should pause before proceding.</p>
</dd>
<dd>
<p>In this implementation, SendKeys always returns after sending the keystrokes.
There is no way to tell if an application has processed those keys when the
function returns.</p>
</dd>
<p></p>
<dt><strong><a name="item_sendmouse"><code>SendMouse($command)</code></a></strong><br />
</dt>
<dd>
This function emulates mouse input.  The COMMAND parameter is a string
containing one or more of the following substrings:
</dd>
<dd>
<pre>
        {LEFTDOWN}    left button down
        {LEFTUP}      left button up
        {MIDDLEDOWN}  middle button down
        {MIDDLEUP}    middle button up
        {RIGHTDOWN}   right button down
        {RIGHTUP}     right button up
        {LEFTCLICK}   left button single click
        {MIDDLECLICK} middle button single click
        {RIGHTCLICK}  right button single click
        {ABSx,y}      move to absolute coordinate ( x, y )
        {RELx,y}      move to relative coordinate ( x, y )</pre>
</dd>
<dd>
<p>Note: Absolute mouse coordinates range from 0 to 65535.
      Relative coordinates can be positive or negative.
      If you need pixel coordinates you can use MouseMoveAbsPix.</p>
</dd>
<dd>
<p>Also equivalent low-level functions are available:</p>
</dd>
<dd>
<pre>
    SendLButtonUp()
    SendLButtonDown()
    SendMButtonUp()
    SendMButtonDown()
    SendRButtonUp()
    SendRButtonDown()
    SendMouseMoveRel(x,y)
    SendMouseMoveAbs(x,y)</pre>
</dd>
<p></p>
<dt><strong><a name="item_mousemoveabspix"><code>MouseMoveAbsPix($x,$y)</code></a></strong><br />
</dt>
<dd>
Move the mouse cursor to the screen pixel indicated as parameter.
</dd>
<dd>
<pre>
  # Moves to x=200, y=100 in pixel coordinates.
  MouseMoveAbsPix(200, 100);</pre>
</dd>
<p></p>
<dt><strong><a name="item_mousemovewheel"><code>MouseMoveWheel($change)</code></a></strong><br />
</dt>
<dd>
<pre>
  Positive or negative value to direct mouse wheel movement.</pre>
</dd>
<dt><strong><a name="item_findwindowlike"><code>FindWindowLike($window,$titleregex,$classregex,$childid,$maxlevel)</code></a></strong><br />
</dt>
<dd>
Finds the window handles of the windows matching the specified parameters and
returns them as a list.
</dd>
<dd>
<p>You may specify the handle of the window to search under. The routine 
searches through all of this windows children and their children recursively.
If 'undef' then the routine searches through all windows. There is also a 
regexp used to match against the text in the window caption and another regexp
used to match against the text in the window class. If you pass a child ID 
number, the functions will only match windows with this id. In each case 
undef matches everything.</p>
</dd>
<p></p>
<dt><strong><a name="item_getwindowid"><code>GetWindowID($window)</code></a></strong><br />
</dt>
<dd>
<pre>
    Returns the control Id of the specified window.</pre>
</dd>
<dt><strong><a name="item_pushbutton"><code>PushButton($button[,$delay])</code></a></strong><br />
</dt>
<dd>
Equivalent to
</dd>
<dd>
<pre>
    PushChildButton(GetForegroundWindow, BUTTON, DELAY)</pre>
</dd>
<p></p>
<dt><strong><a name="item_pushchildbutton"><code>PushChildButton($parent,$button[,$delay])</code></a></strong><br />
</dt>
<dd>
Allows generating a mouse click on a particular button.
</dd>
<dd>
<p>parent - the parent window of the button</p>
</dd>
<dd>
<p>button - either the text in a button (e.g. ``Yes'') or the control ID
of a button.</p>
</dd>
<dd>
<p>delay - the time (0.25 means 250 ms) to wait between the mouse down
and the mouse up event. This is useful for debugging.</p>
</dd>
<p></p>
<dt><strong><a name="item_pushchildbyid">PushChildById( $parent, $button, $level, $delay )</a></strong><br />
</dt>
<dd>
Allows pushing a button, which control id is eqaul to a given parameter.
<a href="#item_pushchildbutton"><code>PushChildButton</code></a> tries to match parameter against control id or
caption.
PushChildById matches only against control id. Secondly, PushChildById
allows specifying search depth in the windows hierarchy tree.
The default is 2, which means that only direct children will be
pushed.
</dd>
<p></p>
<dt><strong><a name="item_waitwindowlike"><code>WaitWindowLike($parent,$wndtitle,$wndclass,$wndid,$depth,$wait)</code></a></strong><br />
</dt>
<dd>
Function which allows one to wait for a window to appear
vs. using hard waits (e.g. sleep 2).
</dd>
<dd>
<p>parent   - Where to start (parent window)</p>
</dd>
<dd>
<p>wndtitle - Regexp for the window title</p>
</dd>
<dd>
<p>wndclass - Regexp for the window class name</p>
</dd>
<dd>
<p>wndid    - Numeric Window or Control ID</p>
</dd>
<dd>
<p>depth    - How deep should we search before we stop</p>
</dd>
<dd>
<p>wait     - How many seconds should we wait before giving up</p>
</dd>
<p></p>
<dt><strong><a name="item_waitwindow"><code>WaitWindow($wndtitle,[$wait])</code></a></strong><br />
</dt>
<dd>
Minimal version of WaitWindowLike. Only requires the window title
regexp. You can also specify the wait timeout in seconds.
</dd>
<dd>
<p>wndtitle - Regexp for the window title</p>
</dd>
<dd>
<p>wait     - How many seconds should we wait before giving up</p>
</dd>
<p></p>
<dt><strong><a name="item_iswindowstyle">IsWindowStyle($window, $style)</a></strong><br />
</dt>
<dd>
<pre>
    Determines if a window has the specified style.  See sample
    script for more details.</pre>
</dd>
<dt><strong><a name="item_iswindowstyleex">IsWindowStyleEx($window, $exstyle)</a></strong><br />
</dt>
<dd>
<pre>
    Determines if a window has the specified extended
    style.  See sample script for more details.</pre>
</dd>
<dt><strong><a name="item_getmenu">GetMenu</a></strong><br />
</dt>
<dd>
Using the corresponding library function (see MSDN) it returns a MenuID number
</dd>
<p></p>
<dt><strong><a name="item_getmenuitemindex">GetMenuItemIndex($curr, $menu);</a></strong><br />
</dt>
<dd>
$curr is a MenuId and $menu is the (localized !) name of the menu including the hot
key:  ``Rep&amp;eate''  
Returns the index of the menu item (-1 if not found)
</dd>
<p></p>
<dt><strong><a name="item_getmenuitemcount"><code>GetMenuItemCount($menu)</code></a></strong><br />
</dt>
<dd>
Returns the number of elements in the given menu.
</dd>
<p></p>
<dt><strong><a name="item_menuselect"><code>MenuSelect($menupath,$window,$menu)</code></a></strong><br />
</dt>
<dd>
Allows selecting a menu programmatically.
</dd>
<dd>
<p>Simple Examples:
    # Exit foreground application through application menu.
    MenuSelect(``&amp;File|E&amp;xit'');</p>
</dd>
<dd>
<pre>
    # Exit foreground application through system menu
    MenuSelect(&quot;&amp;Close&quot;, 0, GetSystemMenu(GetForegroundWindow(), FALSE));</pre>
</dd>
<p></p>
<dt><strong><a name="item_getmenuiteminfo">GetMenuItemInfo($menuHndl, $cnt)</a></strong><br />
</dt>
<dd>
Receives a menu handler (one we got from GetMenu or GetSubMenu) and
a number (which is the location of the item within the given menu).
</dd>
<dd>
<p>Returns a hash of which there are currently 2 keys:
type can be either ``string'' or ``separator''  - this is the type of the menu item
text is the visible text of the menu item (provided only for ``string'' type)</p>
</dd>
<dd>
<p>WARNING: This is an experimental function. Its behavior might change.</p>
</dd>
<p></p>
<dt><strong><a name="item_mouseclick">MouseClick($window [,$parent] [,$x_offset] [,$y_offset] [,$button] [,$delay])</a></strong><br />
</dt>
<dd>
Allows one to easily interact with an application through mouse emulation.
</dd>
<dd>
<p>window = Regexp for a Window caption / Child caption, or just a Child ID.</p>
</dd>
<dd>
<p>parent = Handle to parent window.  Default is foreground window.  Use
<a href="#item_getdesktopwindow"><code>GetDesktopWindow()</code></a> return value for this if clicking on an application
title bar.</p>
</dd>
<dd>
<p>x_offset = Offset for X axis.  Default is 0.</p>
</dd>
<dd>
<p>y_offset = Offset for Y axis.  Default is 0.</p>
</dd>
<dd>
<p>button = {LEFT}, {MIDDLE}, {RIGHT}.  Default is {LEFT}</p>
</dd>
<dd>
<p>delay = Default is 0.  0.50 = 500 ms.  Delay between button down and
button up.</p>
</dd>
<dd>
<p>Simple Examples:</p>
</dd>
<dd>
<pre>
    # Click on CE button if its parent window is in foreground.
    MouseClick('^CE$');</pre>
</dd>
<dd>
<pre>
    # Right click on CE button if its parent window is in foreground
    MouseClick('^CE$', undef, undef, undef, '{RIGHT}');</pre>
</dd>
<dd>
<pre>
    # Click on 8 button window under the specified parent window; where
    # [PARENTHWND] will be replaced by a parent handle variable.
    MouseClick('8', [PARENTHWND]);</pre>
</dd>
<dd>
<pre>
    # Click on Calculator parent window itself
    MouseClick('Calculator', GetDesktopWindow());</pre>
</dd>
<p></p>
<dt><strong><a name="item_allocatevirtualbuffer">$buf_str = AllocateVirtualBuffer( $hwnd, $size )</a></strong><br />
</dt>
<dd>
Allocates memory in the address space of the process, which is an owner of
a window identified by $hwnd. Returns a reference to a hash, which has 2 elements:
</dd>
<dl>
<dt><strong><a name="item_ptr_%2d_address_of_the_allocated_memory">ptr - address of the allocated memory</a></strong><br />
</dt>
<dt><strong><a name="item_handle">process - process handle (in the Win32 meaning, as returned by Win32 OpenProcess
API function</a></strong><br />
</dt>
</dl>
<dt><strong><a name="item_readfromvirtualbuffer">$value = ReadFromVirtualBuffer( $buf_str, $size )</a></strong><br />
</dt>
<dd>
Read from a memory in the address space of the other process.
<code>$buf_str</code> is a reference to a hash returned by AllocateVirtualBuffer.
</dd>
<dd>
<p>Returns read value.</p>
</dd>
<p></p>
<dt><strong><a name="item_writetovirtualbuffer">WriteToVirtualBuffer( $buf_str, $value )</a></strong><br />
</dt>
<dd>
Write to a memory in the address space of the other process.
<code>$buf_str</code> is a reference to a hash returned by AllocateVirtualBuffer.
<code>$value</code> is a value to be copied.
</dd>
<p></p>
<dt><strong><a name="item_freevirtualbuffer">FreeVirtualBuffer( $buf_str )</a></strong><br />
</dt>
<dd>
Frees memory allocated by AllocateVirtualBuffer
</dd>
<p></p>
<dt><strong><a name="item_wmgettext">$text = <code>WMGetText($hwnd)</code> *</a></strong><br />
</dt>
<dd>
Sends a WM_GETTEXT to a window and returns its contents
</dd>
<p></p>
<dt><strong><a name="item_wmsettext">$set = <code>WMSetText(hwnd,text)</code> *</a></strong><br />
</dt>
<dd>
Sends a WM_SETTEXT to a window setting its contents
</dd>
<p></p>
<dt><strong><a name="item_getcursorpos">($x,$y) = <code>GetCursorPos()</code> *</a></strong><br />
</dt>
<dd>
Retrieves the cursor's position,in screen coordinates as (x,y) array.
</dd>
<p></p>
<dt><strong><a name="item_getcaretpos"><code>GetCaretPos()</code></a></strong><br />
</dt>
<dd>
Retrieves the caret's position, in client coordinates as (x,y) array. (Like Windows function)
</dd>
<p></p>
<dt><strong><a name="item_setfocus">HWND <code>SetFocus(hWnd)</code></a></strong><br />
</dt>
<dd>
Sets the keyboard focus to the specified window
</dd>
<p></p>
<dt><strong><a name="item_getdesktopwindow">HWND <code>GetDesktopWindow()</code> *</a></strong><br />
</dt>
<dd>
Returns a handle to the desktop window
</dd>
<p></p>
<dt><strong><a name="item_getwindow">HWND <code>GetWindow(hwnd,uCmd)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_getwindowtext">SV * <code>GetWindowText(hwnd)</code> *</a></strong><br />
</dt>
<dd>
Get the text name of the window as shown on the top of it.
Beware, this is text depends on localization.
</dd>
<p></p>
<dt><strong><a name="item_getclassname">$class = <code>GetClassName(hwnd)</code> *</a></strong><br />
</dt>
<dd>
Using the same Windows library function returns the name
of the class wo which the specified window belongs.
</dd>
<dd>
<p>See MSDN for more details.</p>
</dd>
<dd>
<p>You can also check out MSDN to see an overview of the Window Classes.</p>
</dd>
<p></p>
<dt><strong><a name="item_getparent">HWND <code>GetParent(hwnd)</code> *</a></strong><br />
</dt>
<dd>
A library function (see MSDN) to return the WindowID of the parent window.
See MSDN for the special cases.
</dd>
<p></p>
<dt><strong><a name="item_getwindowlong">long <code>GetWindowLong(hwnd,index)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_setforegroundwindow">BOOL <code>SetForegroundWindow(hWnd)</code> *</a></strong><br />
</dt>
<dd>
See corresponding Windows functions.
</dd>
<p></p>
<dt><strong><a name="item_getchildwindows">@wnds = <code>GetChildWindows(hWnd)</code></a></strong><br />
</dt>
<dd>
Using EnumChildWindows library function (see MSDN) it returns the WindowID 
of each child window. If the children have their own children the function
returns them too until the tree ends.
</dd>
<p></p>
<dt><strong><a name="item_ischild">BOOL <code>IsChild(hWndParent,hWnd)</code> *</a></strong><br />
</dt>
<dd>
Using the corresponding library function (see MSDN) it returns true
if the second window is an immediate child or a descendant window of
the first window.
</dd>
<p></p>
<dt><strong><a name="item_getchilddepth">$depth = <code>GetChildDepth(hAncestor,hChild)</code></a></strong><br />
</dt>
<dd>
Using the GetParent library function in a loop, returns the distance
between an ancestor window and a child (descendant) window.
</dd>
<dd>
<p>Features/bugs:
If the given ``ancsetor'' is not really an ancestor, the return value is the distance of child from the root window (0)
If you supply the same id for both the ancestor and the child you get 1.
If the ancestor you are checking is not 0 then the distance given is 1 larger than it should be.</p>
</dd>
<dd>
<p>see eg\get_child_depth.pl</p>
</dd>
<p></p>
<dt><strong><a name="item_sendmessage">$res = <code>SendMessage(hWnd,Msg,wParam,lParam)</code> *</a></strong><br />
</dt>
<dd>
This is a library function (see MSDN) used by a number of the functions provided by
Win32::GuiTest. It sends the specified message to a window or windows.
HWnd is the WindowID or HWND_BROADCAST to send message to all top level windows.
     Message is not sent to child windows. (If I understand this correctly this means
     it is sent to all the immediate children of the root window (0).
Msg  the message
wParam additional parameter
lParam additioanl parameter
</dd>
<dd>
<p>It is most likely you won't use this directly but through one of the functions
implemented already in Win32::GuiTest.</p>
</dd>
<dd>
<p>See the guitest.xs for some examples.</p>
</dd>
<p></p>
<dt><strong><a name="item_postmessage">$res = <code>PostMessage(hwnd,msg,wParam,lParam)</code> *</a></strong><br />
</dt>
<dd>
See corresponding Windows library function in MSDN.
</dd>
<p></p>
<dt><strong><a name="item_checkbutton"><code>CheckButton(hwnd)</code></a></strong><br />
</dt>
<dt><strong><a name="item_uncheckbutton"><code>UnCheckButton(hwnd)</code></a></strong><br />
</dt>
<dt><strong><a name="item_grayoutbutton"><code>GrayOutButton(hwnd)</code></a></strong><br />
</dt>
<dt><strong><a name="item_ischeckedbutton">BOOL <code>IsCheckedButton(hwnd)</code></a></strong><br />
</dt>
<dt><strong><a name="item_isgrayedbutton">BOOL <code>IsGrayedButton(hwnd)</code></a></strong><br />
</dt>
<dd>
The names say it.  Works on radio buttons and
checkboxes.  For regular buttons, use IsWindowEnabled.
</dd>
<p></p>
<dt><strong><a name="item_iswindow">BOOL <code>IsWindow(hwnd)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_screentoclient">($x,$y) = <code>ScreenToClient(hwnd,x,y)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_clienttoscreen">($x,$y) = <code>ClientToScreen(hwnd,x,y)</code> *</a></strong><br />
</dt>
<dt><strong>($x,$y) = <code>GetCaretPos(hwnd)</code> *A</strong><br />
</dt>
<dt><strong>HWND <code>SetFocus(hWnd)</code> *A</strong><br />
</dt>
<dt><strong><a name="item_getfocus">HWND <code>GetFocus(hwnd)</code> *A</a></strong><br />
</dt>
<dt><strong><a name="item_getactivewindow">HWND <code>GetActiveWindow(hwnd)</code> *A</a></strong><br />
</dt>
<dt><strong><a name="item_getforegroundwindow">HWND <code>GetForegroundWindow()</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_setactivewindow">HWND <code>SetActiveWindow(hwnd)</code> *A</a></strong><br />
</dt>
<dt><strong><a name="item_enablewindow">BOOL <code>EnableWindow(hwnd,fEnable)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_iswindowenabled">BOOL IsWindowEnabled(hwnd)*</a></strong><br />
</dt>
<dt><strong><a name="item_iswindowvisible">BOOL IsWindowVisible(hwnd)*</a></strong><br />
</dt>
<dt><strong><a name="item_showwindow">BOOL <code>ShowWindow(hwnd,nCmdShow)</code> *A</a></strong><br />
</dt>
<dd>
See corresponding Windows functions.
</dd>
<p></p>
<dt><strong><a name="item_screentonorm">($x,$y) = <code>ScreenToNorm(x,y)</code></a></strong><br />
</dt>
<dd>
Returns normalised coordinates of given point (0-FFFF as a fraction of screen 
resolution)
</dd>
<p></p>
<dt><strong><a name="item_normtoscreen">($x,$y) = <code>NormToScreen(x,y)</code></a></strong><br />
</dt>
<dd>
The opposite transformation
</dd>
<p></p>
<dt><strong><a name="item_getscreenres">($x,$y) = <code>GetScreenRes()</code></a></strong><br />
</dt>
<dd>
Returns screen resolution
</dd>
<p></p>
<dt><strong><a name="item_windowfrompoint">HWND WindowFromPoint(x, y)</a></strong><br />
</dt>
<dt><strong><a name="item_getwindowrect">($l,$t,$r,$b) = <code>GetWindowRect(hWnd)</code> *</a></strong><br />
</dt>
<dt><strong><a name="item_getclientrect">($l,$t,$r,$b) = <code>GetClientRect(hWnd)</code> *</a></strong><br />
</dt>
<dd>
See corresponding Windows functions.
</dd>
<p></p>
<dt><strong><a name="item_selcomboitem">SelComboItem($window, $index)</a></strong><br />
</dt>
<dd>
Selects an item in the combo box based off an index (zero-based).
</dd>
<p></p>
<dt><strong><a name="item_selcomboitemtext">SelComboItemText($window, $txt)</a></strong><br />
</dt>
<dd>
Selects an item in the combo box based off text (case insensitive).
</dd>
<p></p>
<dt><strong><a name="item_getcombotext">$txt = <code>GetComboText(hwnd,index)</code></a></strong><br />
</dt>
<dt><strong><a name="item_getlisttext">$txt = <code>GetListText(hwnd,index)</code></a></strong><br />
</dt>
<dt><strong><a name="item_getcombocontents">@lst = <code>GetComboContents(hWnd)</code></a></strong><br />
</dt>
<dt><strong><a name="item_getlistcontents">@lst = <code>GetListContents(hWnd)</code></a></strong><br />
</dt>
<dd>
Fetch the contents of the list and combo boxes.
</dd>
<p></p>
<dt><strong><a name="item_iskeypressed"><code>IsKeyPressed($key)</code></a></strong><br />
</dt>
<dd>
Wrapper around the GetAsyncKeyState API function. Returns TRUE if the user presses the 
specified key.
</dd>
<dd>
<pre>
    IsKeyPressed(&quot;ESC&quot;);
    IsKeyPressed(&quot;A&quot;);
    IsKeyPressed(&quot;DOWN&quot;);</pre>
</dd>
<p></p>
<dt><strong><a name="item_sendrawkey"><code>SendRawKey($virtualkey,$flags)</code></a></strong><br />
</dt>
<dd>
Wrapper around keybd_event. Allows sending low-level keys. The first argument is any of the VK_* constants. The second argument can be 0, KEYEVENTF_EXTENDEDKEY, KEYEVENTF_KEYUP or a combination of them.
</dd>
<dd>
<pre>
    KEYEVENTF_EXTENDEDKEY - Means it is an extended key (i.e. to distinguish between arrow keys on the numeric keypad and elsewhere). 
    KEYEVENTF_KEYUP       - Means keyup. Unspecified means keydown.</pre>
</dd>
<dd>
<pre>
   #Example
   use Win32::GuiTest qw/:FUNC :VK/;</pre>
</dd>
<dd>
<pre>
   while (1) {
       SendRawKey(VK_DOWN, KEYEVENTF_EXTENDEDKEY); 
       SendKeys &quot;{PAUSE 200}&quot;;
   }</pre>
</dd>
<p></p>
<dt><strong><a name="item_getlistviewcontents"><code>GetListViewContents($handle)</code></a></strong><br />
</dt>
<dd>
<pre>
    Return the items of the list view with C&lt;$handle&gt; as a list, each
        element of which is a reference to an array containing the values
        in each column.</pre>
</dd>
<dt><strong><a name="item_sellistviewitem">SelListViewItem($window, $idx, [$multi_select])</a></strong><br />
</dt>
<dd>
<pre>
    Selects an item in the list view based off an index (zero-based).</pre>
</dd>
<dd>
<pre>
        # Select first item, clears out any previous selections.
        SelListViewItem($win, 0);
        # Select an *additional* item.
        SelListViewItem($win, 1, 1);</pre>
</dd>
<dt><strong><a name="item_sellistviewitemtext">SelListViewItemText($window, $txt, [$multi_select])</a></strong><br />
</dt>
<dd>
<pre>
    Selects an item in the list view based off text (case insensitive).</pre>
</dd>
<dd>
<pre>
        # Select first item, clears out any previous selections.
        SelListViewItemText($win, 'Temp');
        # Select an *additional* item.
        SelListViewItemText($win, 'cabs', 1);</pre>
</dd>
<dt><strong><a name="item_islistviewitemsel">IsListViewItemSel($window, $txt)</a></strong><br />
</dt>
<dd>
<pre>
   Determines if the specified list view item is selected.</pre>
</dd>
<dt><strong><a name="item_gettabitems"><code>GetTabItems($window)</code></a></strong><br />
</dt>
<dd>
<pre>
    Returns a list of a tab control's labels.</pre>
</dd>
<dt><strong><a name="item_seltabitem">SelTabItem($window, $idx)</a></strong><br />
</dt>
<dd>
<pre>
    Selects a tab based off an index (zero-based).</pre>
</dd>
<dt><strong><a name="item_seltabitemtext">SelTabItemText($window, $txt)</a></strong><br />
</dt>
<dd>
<pre>
    Selects a tab based off text label (case insensitive).</pre>
</dd>
<dt><strong><a name="item_istabitemsel">IsTabItemSel($window, $txt)</a></strong><br />
</dt>
<dd>
<pre>
   Determines if the specified tab item is selected.</pre>
</dd>
<dt><strong><a name="item_seltreeviewitempath">SelTreeViewItemPath($window, $path)</a></strong><br />
</dt>
<dd>
<pre>
    Selects a tree view item based off a &quot;path&quot; (case insensitive).</pre>
</dd>
<dd>
<pre>
    # Select Machine item and Processors sub-item.
    SelTreeViewItemPath($window, &quot;Machine|Processors&quot;);</pre>
</dd>
<dd>
<pre>
    SelTreeViewItemPath($window, &quot;Item&quot;);</pre>
</dd>
<dt><strong><a name="item_gettreeviewselpath"><code>GetTreeViewSelPath($window)</code></a></strong><br />
</dt>
<dd>
<pre>
   Returns a string containing the path (i.e., &quot;parent|child&quot;) of
   the currently selected tree view item.</pre>
</dd>
<dd>
<pre>
   $oldpath = GetTreeViewSelPath($window);
   SelTreeViewItemPath($window, &quot;Parent|Child&quot;);
   SelTreeViewItemPath($window, $oldpath);</pre>
</dd>
<dt><strong><a name="item_getpopuphandle">$hpopup = GetPopupHandle($hwnd, $x, $y, [$wait])</a></strong><br />
</dt>
<dd>
<pre>
   This function gets the handle of a popup window generated by
   right-clicking at the $x and $y screen coordinates (absolute). An
   optional delay can be entered which will wait the given number of
   milliseconds after the right-click for the window to appear (default
   is 50). Zero is returned when no popup menu is found.</pre>
</dd>
</dl>
<p>
</p>
<h2><a name="dibsect">DibSect</a></h2>
<p>A class to manage a Windows DIB section. Currently limited in functionality to 
24-bit images. Pulled from old code into GuiTest when I (<a href="mailto:jurasz@imb.uni-karlsruhe.de">jurasz@imb.uni-karlsruhe.de</a>) 
needed to create several grayscale screen dumps.</p>
<p>Possible future extenstions: other color resolutions, loading, comparison of bitmaps,
getting from clipboard.</p>
<p>Synopsis:</p>
<pre>
  $ds = new Win32::GuiTest::DibSect;
  $ds-&gt;CopyWindow($w);
  $ds-&gt;ToGrayScale();
  $ds-&gt;SaveAs(&quot;bla.bmp&quot;);
  $ds-&gt;ToClipboard();</pre>
<dl>
<dt><strong><a name="item_copyclient">bool DibSect::CopyClient(hwnd,[rect])</a></strong><br />
</dt>
<dd>
Copy a client area of given window (or possibly its subset) into a given DibSect.
The rectangle may be optionally passed as a reference to 4-element array.
To get the right result make sure the window you want to copy is not obscured by 
others.
</dd>
<p></p>
<dt><strong><a name="item_copywindow">bool DibSect::CopyWindow(hwnd)</a></strong><br />
</dt>
<dd>
Copy the window rectangle. Equivalent to
</dd>
<dd>
<pre>
  $ds-&gt;CopyClient(GetDesktopWindow(), \@{[GetWindowRect($w)]});</pre>
</dd>
<p></p>
<dt><strong><a name="item_saveas">bool DibSect::SaveAs(szFile)</a></strong><br />
</dt>
<dd>
Save the current contents of the DIB section in a given file. With 24-bit 
resolution it can grow quite big, so I immediately convert them to PNG (direct 
writing of PNG seemed to complicated to implement).
</dd>
<p></p>
<dt><strong><a name="item_invert">bool DibSect::Invert()</a></strong><br />
</dt>
<dd>
Invert the colors in a current DIB section.
</dd>
<p></p>
<dt><strong><a name="item_tograyscale">bool DibSect::ToGrayScale()</a></strong><br />
</dt>
<dd>
Convert the DibSection to the gray scale. Note that it is still encoded as 24-bit
BMP for simplicity.
</dd>
<p></p>
<dt><strong><a name="item_toclipboard">bool DibSect::ToClipboard()</a></strong><br />
</dt>
<dd>
Copies the DibSect to clipboard (as an old-fashioned metafile), so that it can 
be further processed with your favourite image processing software, for example 
automatically using SendKeys.
</dd>
<p></p>
<dt><strong><a name="item_destroy">bool DibSect::Destroy()</a></strong><br />
</dt>
<dd>
Destroys the contents of the DIB section.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="development">DEVELOPMENT</a></h1>
<p>If you would like to participate in the development of this module there are 
several thing that need to be done. For some of them you only need Perl
and the latest source of the module from CVS for others you'll also need to 
have a C++ compiler.</p>
<p>To get the latest source code you need a CVS client and then do the following:</p>
<pre>
 cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest login
 cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest co Win32-GuiTest</pre>
<p>See more detailed explanations here <a href="http://sourceforge.net/projects/winguitest/">http://sourceforge.net/projects/winguitest/</a></p>
<p>To setup a development environment for compiling the C++ code you can either buy
Visual Studio with Visual C++ or you can download a few things free of charge from 
Microsoft. There might be other ways too we have not explored.</p>
<p>The instructions to get the free environment are here:</p>
<p>From <a href="http://www.microsoft.com/">http://www.microsoft.com/</a> download and install:</p>
<pre>
 1) Microsoft .NET Framework Version 1.1 Redistributable Package
 2) .NET Framework SDK Version 1.1</pre>
<p>This is not enough as there are a number of header files and libraries that are 
not included in these distributions. You can get them from Microsoft in two additional
downloads. For these you will have to be using Internet Explorer.
Visit</p>
<pre>
  <a href="http://www.microsoft.com/msdownload/platformsdk/sdkupdate/">http://www.microsoft.com/msdownload/platformsdk/sdkupdate/</a></pre>
<p>and install</p>
<pre>
 1) Core SDK
 2) Microsoft Data Access Components 2.7</pre>
<p>Before you can compile you'll have to open a command prompt and execute the
<code>sdkvars.bat</code> script from the.NET SDK that will set a number of environment
variables. In addition you'll have to run the <code>setenv.bat</code> you got with the 
Core SDK (and located in C:\Program Files\Microsoft SDK) with the appropriate
parameters. For me this was /XP32 /RETAIL</p>
<p>In order to finish the packaging you'll also need the tar, gzip and zip utilities from</p>
<pre>
 <a href="http://gnuwin32.sourceforge.net/packages.html">http://gnuwin32.sourceforge.net/packages.html</a></pre>
<p>I have not tried it yet.</p>
<p>After this you will probably be able to do the normal cycle:</p>
<pre>
 perl makefile.pl
 nmake
 nmake test</pre>
<pre>
 or run</pre>
<pre>
 perl makedist.pl</pre>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>Module's documentation is available at <a href="http://www.piotrkaluski.com/files/winguitest/docs/index.html">http://www.piotrkaluski.com/files/winguitest/docs/index.html</a>.</p>
<p>
</p>
<hr />
<h1><a name="todo">TODO</a></h1>
<p>Here are a few items where help would be welcome.</p>
<p>
</p>
<h2><a name="perl_only">Perl only</a></h2>
<pre>
 Improve Tests
 Improve documentation
 Add more examples and explain them</pre>
<p>
</p>
<h2><a name="c++_compiler_needed">C++ compiler needed</a></h2>
<pre>
 Add more calls to the C++ backend
 Fix current calls</pre>
<pre>
 32bit custom controls (some already implemented)
 Possibly Java interfaces
 Retreive the list of the menu of a given window.</pre>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<pre>
    1.50.4</pre>
<p>
</p>
<hr />
<h1><a name="changes">CHANGES</a></h1>
<p>Moved to the CHANGES file.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>The SendKeys function is based on the Delphi sourcecode
published by Al Williams  &lt;<a href="http://www.al-williams.com/awc/">http://www.al-williams.com/awc/</a>&gt; 
in Dr.Dobbs  &lt;<a href="http://www.ddj.com/ddj/1997/careers1/wil2.htm">http://www.ddj.com/ddj/1997/careers1/wil2.htm</a>&gt;.</p>
<p>Copyright (c) 1998-2002 Ernesto Guisado, (c) 2004 Dennis K. Paulsen. All rights 
reserved. This program is free software; You may distribute it and/or modify it
under the same terms as Perl itself.</p>
<p>
</p>
<hr />
<h1><a name="authors">AUTHORS</a></h1>
<p>Ernesto Guisado (<a href="mailto:erngui@acm.org">erngui@acm.org</a>), <a href="http://triumvir.org">http://triumvir.org</a></p>
<p>Jarek Jurasz (<a href="mailto:jurasz@imb.uni-karlsruhe.de">jurasz@imb.uni-karlsruhe.de</a>), <a href="http://www.uni-karlsruhe.de/~gm07">http://www.uni-karlsruhe.de/~gm07</a> wrote 
DibSect and some other pieces (see <code>Changes</code> for details).</p>
<p>Dennis K. Paulsen (<a href="mailto:ctrondlp@cpan.org">ctrondlp@cpan.org</a>) wrote various pieces (See <code>Changes</code> for
details).</p>
<p>
</p>
<hr />
<h1><a name="credits">CREDITS</a></h1>
<p>Thanks very much to:</p>
<dl>
<dt><strong><a name="item_johannes_maehner">Johannes Maehner</a></strong><br />
</dt>
<dt><strong><a name="item_ben_shern">Ben Shern</a></strong><br />
</dt>
<dt><strong><a name="item_phill_wolf">Phill Wolf</a></strong><br />
</dt>
<dt><strong><a name="item_mauro">Mauro</a></strong><br />
</dt>
<dt><strong><a name="item_sohrab_niramwalla">Sohrab Niramwalla</a></strong><br />
</dt>
<dt><strong><a name="item_frank_van_dijk">Frank van Dijk</a></strong><br />
</dt>
<dt><strong><a name="item_jarek_jurasz">Jarek Jurasz</a></strong><br />
</dt>
<dt><strong><a name="item_wilson_p%2e_snyder_ii">Wilson P. Snyder II</a></strong><br />
</dt>
<dt><strong><a name="item_rudi_farkas">Rudi Farkas</a></strong><br />
</dt>
<dt><strong><a name="item_paul_covington">Paul Covington</a></strong><br />
</dt>
<dt><strong><a name="item_piotr_kaluski">Piotr Kaluski</a></strong><br />
</dt>
<dt><strong><a name="item_%2e%2e%2eand_more%2e%2e%2e">...and more...</a></strong><br />
</dt>
<dd>
for code, suggestions and bug fixes.
</dd>
<p></p></dl>

</body>

</html>
