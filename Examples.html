<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Win32::GuiTest::Examples - collection of the scripts from eg</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">Synopsis</a></li>
	<li><a href="#examples">Examples</a></li>
	<ul>

		<li><a href="#eg/ask.pl">eg/ask.pl</a></li>
		<li><a href="#eg/calc.pl">eg/calc.pl</a></li>
		<li><a href="#eg/excel.pl">eg/excel.pl</a></li>
		<li><a href="#eg/excel2.pl">eg/excel2.pl</a></li>
		<li><a href="#eg/fonts.pl">eg/fonts.pl</a></li>
		<li><a href="#eg/iswindowstyle.pl">eg/iswindowstyle.pl</a></li>
		<li><a href="#eg/keypress.pl">eg/keypress.pl</a></li>
		<li><a href="#eg/menuselect.pl">eg/menuselect.pl</a></li>
		<li><a href="#eg/notepad.pl">eg/notepad.pl</a></li>
		<li><a href="#eg/notepad_text.pl">eg/notepad_text.pl</a></li>
		<li><a href="#eg/paint.pl">eg/paint.pl</a></li>
		<li><a href="#eg/paint_abs.pl">eg/paint_abs.pl</a></li>
		<li><a href="#eg/pushbutton.pl">eg/pushbutton.pl</a></li>
		<li><a href="#eg/rawkey.pl">eg/rawkey.pl</a></li>
		<li><a href="#eg/selecttabitem.pl">eg/selecttabitem.pl</a></li>
		<li><a href="#eg/showcpl.pl">eg/showcpl.pl</a></li>
		<li><a href="#eg/showmouse.pl">eg/showmouse.pl</a></li>
		<li><a href="#eg/showwin.pl">eg/showwin.pl</a></li>
		<li><a href="#eg/spy.pl">eg/spy-.pl</a></li>
		<li><a href="#eg/spy.pl">eg/spy.pl</a></li>
		<li><a href="#eg/start.pl">eg/start.pl</a></li>
		<li><a href="#eg/tab.pl">eg/tab.pl</a></li>
		<li><a href="#eg/waitwindow.pl">eg/waitwindow.pl</a></li>
		<li><a href="#eg/which.pl">eg/which.pl</a></li>
		<li><a href="#eg/winbmp.pl">eg/winbmp.pl</a></li>
		<li><a href="#eg/wptr.pl">eg/wptr.pl</a></li>
	</ul>

</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Win32::GuiTest::Examples - collection of the scripts from eg</p>
<p>
</p>
<hr />
<h1><a name="synopsis">Synopsis</a></h1>
<p>This module was autogenerated from the files in the eg directory of
the distribution. For detailed (cough) documenataion see <a href="/Win32/GuiTest.html">the Win32::GuiTest manpage</a>.
To run the examples either copy-paste them from here or download and unpack
the distribution and take the files from the eg directory.</p>
<p>
</p>
<hr />
<h1><a name="examples">Examples</a></h1>
<p>
</p>
<h2><a name="eg/ask.pl">eg/ask.pl</a></h2>
<pre>
    #!perl -w
    
    # $Id: ask.pl,v 1.4 2004/07/19 20:20:58 szabgab Exp $
    #
    # Just ask a number of questions on the command line using
    # the functions provided by Win32::GuiTest::Cmd
    
    use strict;
    use Win32::GuiTest::Cmd ':ALL';
    
    Pause(&quot;Press ENTER to start the setup...&quot;);
    
    print &quot;GO!\n&quot; if YesOrNo(&quot;Setup networking component?&quot;);
    
    my $address = AskForIt(&quot;What's your new ip address?&quot;, 
        &quot;122.122.122.122&quot;);
    
    my $dir = AskForDir(&quot;Where should I put the new files?&quot;, 
        &quot;c:\\temp&quot;);
    
    my $exe = AskForExe(&quot;Where is your net setup program?&quot;, 
        &quot;/foo/bar.exe&quot;);
    
    print &quot;\nAddress '$address'\n&quot;;
    print &quot;Dir     '$dir'\n&quot;;
    print &quot;Exe     '$exe'\n&quot;;</pre>
<p>
</p>
<h2><a name="eg/calc.pl">eg/calc.pl</a></h2>
<pre>
    #!perl -w
    
    #$Id: calc.pl,v 1.1 2004/07/17 16:07:42 szabgab Exp $
    #
    # Written by Gabor Szabo &lt;gabor@pti.co.il&gt;
    # An example how to access the built in calculator (calc.exe) of Windows.
    # This code assumes your calulator defaults to the Standard view (and not the Scientific)
    
    
    
    use strict;
    
    use Win32::GuiTest qw(:ALL);
    
    if (not @ARGV or 
        ($ARGV[0] ne &quot;keyboard&quot; and  $ARGV[0] ne &quot;mouse&quot;)) {
        die &quot;Usage: $0 [keyboard|mouse]\n&quot; 
    }
       
    system &quot;start calc.exe&quot;;
    sleep(1);
    my @windows = FindWindowLike(undef, &quot;Calculator&quot;);
    
    if (not @windows) {
       die &quot;Could not find Calculator\n&quot;;
    }
    if (@windows &gt; 1) {
       die &quot;There might be more than one Calculators running\n&quot;;
    }
    
    if ($ARGV[0] eq &quot;keyboard&quot;) {
       PushButton '7';  
       sleep(1);
       PushButton '\*';
       sleep(1);
       PushButton '5';
       sleep(1);
       PushButton '=';
       sleep(2);
       
       # Catch the content of the first child, 
       # At this point we can only hope that this is the child that holds the result
       # as it does not have a title, maybe it has a type that we can check ?
       my @children = GetChildWindows($windows[0]);
       printf &quot;Result: %s\n&quot;, WMGetText($children[0]);
       
       SendKeys(&quot;%{F4}&quot;);  # Alt-F4 to exit
    }
    if ($ARGV[0] eq &quot;mouse&quot;) {
       my ($left, $top, $right, $bottom) = GetWindowRect($windows[0]);
       # find the appropriate child window and click on  it
       my @children = GetChildWindows($windows[0]);
       foreach my $title (qw(7 * 5 =)) {
           my ($c) = grep {$title eq GetWindowText($_)} @children;
           my ($left, $top, $right, $bottom) = GetWindowRect($c);
           MouseMoveAbsPix(($right+$left)/2,($top+$bottom)/2);
           SendMouse(&quot;{LeftClick}&quot;);
           sleep(1);
       }
       printf &quot;Result: %s\n&quot;, WMGetText($children[0]);
       
       MouseMoveAbsPix($right-10,$top+10);  # this probably depends on the resolution
       sleep(2);
       SendMouse(&quot;{LeftClick}&quot;);
    }</pre>
<p>
</p>
<h2><a name="eg/excel.pl">eg/excel.pl</a></h2>
<pre>
    #!perl -w
    # $Id: excel.pl,v 1.4 2004/07/19 20:20:58 szabgab Exp $
    #
    
    use strict;
    
    use Win32::GuiTest qw(FindWindowLike GetWindowText SetForegroundWindow);
    
    $Win32::GuiTest::debug = 0; # Set to &quot;1&quot; to enable verbose mode
    
    # Find top level (1) windows containg Excel in their title
    my @windows = FindWindowLike(undef, &quot;Excel&quot;, &quot;&quot;, undef, 1);
    for (@windows) {
        print &quot;$_&gt;\t'&quot;, GetWindowText($_), &quot;'\n&quot;;
    }
    print &quot;------------\n&quot;;
    
    # Find all windows matching Microsoft Excel in the title, and XLMAIN$
    # as the class. 
    @windows = FindWindowLike(undef, &quot;^Microsoft Excel&quot;, &quot;^XLMAIN\$&quot;);
    for (@windows) {
        print &quot;$_&gt;\t'&quot;, GetWindowText($_), &quot;'\n&quot;;
        SetForegroundWindow($_);
    }
    print &quot;------------\n&quot;;
    
    die &quot;You should start Excel before running this example.\n&quot;
        unless @windows;
    
    # Find all children of a specified window.
    my @children = FindWindowLike($windows[0]);
    for (@children) {
        print &quot;$_&gt;\t'&quot;, GetWindowText($_), &quot;'\n&quot;;
    }</pre>
<p>
</p>
<h2><a name="eg/excel2.pl">eg/excel2.pl</a></h2>
<pre>
    #!perl -w
    
    # $Id: excel2.pl,v 1.4 2004/07/19 20:20:58 szabgab Exp $
    #
    # Exercise Win32::GuiTest using MS-Excel. Will only work with non-localized
    # versions of Excel (hard-coded hot-keys).
    #
    
    use strict;
    use Win32::GuiTest qw(FindWindowLike GetWindowText 
    SetForegroundWindow SendKeys);
    
    $Win32::GuiTest::debug = 0; # Set to &quot;1&quot; to enable verbose mode
    
    my @windows = FindWindowLike(0, &quot;^Microsoft Excel&quot;, &quot;^XLMAIN\$&quot;);
    
    die &quot;You should start Excel before running this example.\n&quot;
        unless @windows;
    
    print &quot;$windows[0]&gt;\t'&quot;, GetWindowText($windows[0]), &quot;'\n\n&quot;;
    SetForegroundWindow($windows[0]);
    SendKeys(&quot;%fn~{PAUSE 1000}&quot;);
    SendKeys(&quot;Randal, look!{TAB}&quot;);
    SendKeys(&quot;Just{TAB}Another{TAB}Perl{TAB}Hacker{TAB}&quot;);
    SendKeys(&quot;{DOWN}{LEFT 5}This is another test!{TAB}{DOWN}{LEFT}&quot;);
    SendKeys(&quot;I hope we're on cell A3!{ENTER}&quot;);
    
    my @xl_children = FindWindowLike($windows[0]);
    for (@xl_children) {
        print &quot;$_&gt;\t'&quot;, GetWindowText($_), &quot;'\n&quot;;
    }
    
    print &quot;\n&quot;;
    
    SendKeys(&quot;{PAUSE 2000}%to{PAUSE 2000}&quot;);
    SendKeys(&quot;{ESC}Test finished.{ENTER}&quot;);</pre>
<p>
</p>
<h2><a name="eg/fonts.pl">eg/fonts.pl</a></h2>
<pre>
    #!perl -w
    # $Id: fonts.pl,v 1.4 2004/07/19 20:20:58 szabgab Exp $
    # Use Win32::GuiTest to get a list of supported fonts from a
    # dialog box.
    # By Ernesto Guisado (erngui@acm.org).
    
    use strict;
    
    use Win32::GuiTest qw(:ALL);
    
    #sub FontTxt { &quot;Fuente&quot;; } # i18n
    #sub OpenFont { &quot;%ef&quot;; }   # i18n
    
    # Let's see notepad
    system(&quot;start notepad.exe&quot;);
    sleep 1;
    
    # Open the Font dialog
    #SendKeys(OpenFont);
    MenuSelect(&quot;F&amp;ormat|&amp;Font&quot;);  # this is also language dependent !
    sleep(1);
    
    # Find the Font dialog using the title and window class
    # The Font dialog isn't a child of the notepad window
    #my ($fontdlg) = FindWindowLike(0, FontTxt); 
    my $fontdlg = GetForegroundWindow();
    die &quot;We could not fing the Font dialog\n&quot; if not defined $fontdlg;
    print GetWindowText($fontdlg), &quot;\n\n&quot;;
    sleep(3);
    
    # Find the right combo using it's control id
    my ($combo) = FindWindowLike($fontdlg, &quot;&quot;, &quot;ComboBox&quot;, 0x470);
    die &quot;Where is the combo with the font names?&quot; unless $combo;
    
    # Print all the font names
    for (GetComboContents($combo)) {
        print &quot;'$_'&quot; . &quot;\n&quot;;
    }
    
    # Close the dialog and notepad
    SendKeys(&quot;{ESC}%{F4}&quot;);</pre>
<p>
</p>
<h2><a name="eg/iswindowstyle.pl">eg/iswindowstyle.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: iswindowstyle.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    #
    
    use Win32::GuiTest qw(:FUNC :LVS);
    
    # Test IsWindowStyle()
    
    # Get handle to desktop listview.  Note: Tested on Win2k and NT4.
    my ($pm) = FindWindowLike(GetDesktopWindow(), &quot;&quot;, &quot;Progman&quot;);
    my ($sdv) = FindWindowLike($pm, &quot;&quot;, &quot;SHELLDLL_DefView&quot;);
    my ($dlv) = FindWindowLike($sdv, &quot;&quot;, &quot;SysListView32&quot;);
    # Check to see if desktop icons are marked for auto-arrange.
    if (IsWindowStyle($dlv, LVS_AUTOARRANGE)) {
        print &quot;Desktop icons are set to auto-arranged.\n&quot;;
    } else {
        print &quot;Desktop icons are NOT set to auto-arranged.\n&quot;;
        ## Code to auto-arrange desktop icons (MouseClick,SendKeys) ##
    }</pre>
<p>
</p>
<h2><a name="eg/keypress.pl">eg/keypress.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: keypress.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    # This example shows an easy way to check for certain keystrokes.
    # The IsKeyPressed function takes a string with the name of the key.
    # This names are the same ones as for SendKeys. 
    
    use Win32::GuiTest qw(SendKeys IsKeyPressed);
    
    # Wait until user presses several specified keys
    @keys = qw/ESC F5 F11 F12 A B 8 DOWN/;
    
    for (@keys) {
      until (IsKeyPressed($_)) {
        print &quot;Please press $_...\n&quot;;
        SendKeys &quot;{PAUSE 200}&quot;;
      }
    }</pre>
<p>
</p>
<h2><a name="eg/menuselect.pl">eg/menuselect.pl</a></h2>
<pre>
    #!perl -w
    # $Id: menuselect.pl,v 1.8 2004/07/28 11:45:13 szabgab Exp $
    
    # Example how to get the names of the menus
    
    use strict;
    
    use Win32::GuiTest qw(:ALL);
    
    system &quot;start notepad&quot;;
    sleep 1;
    
    my $menu = GetMenu(GetForegroundWindow());
    print &quot;Menu: $menu\n&quot;;
    my $submenu = GetSubMenu($menu, 0);
    print &quot;Submenu: $submenu\n&quot;;
    print &quot;Count:&quot;, GetMenuItemCount($menu), &quot;\n&quot;;
    
    use Data::Dumper;
    
    my %h = GetMenuItemInfo($menu, 1);   # Edit on the main menu
    print Dumper \%h;
    %h = GetMenuItemInfo($submenu, 1);   # Open in the File menu
    print Dumper \%h;
    %h = GetMenuItemInfo($submenu, 4);   # Separator in the File menu
    print Dumper \%h;
    
    print &quot;===================\n&quot;;
    menu_parse($menu);
    
    #MenuSelect(&quot;&amp;Archivo|&amp;Salir&quot;);
    
    # Close the menu and notepad
    SendKeys(&quot;{ESC}%{F4}&quot;);
    
    
    # this function receives a menu id and prints as much information about that menu and 
    # all its submenues as it can
    # One day we might include this in the distributionor in some helper module
    sub menu_parse {
        my ($menu, $depth) = @_;
        $depth ||= 0;
        
        foreach my $i (0..GetMenuItemCount($menu)-1) {
                my %h = GetMenuItemInfo($menu, $i);
                print &quot;   &quot; x $depth;
                print &quot;$i  &quot;;
                print $h{text} if $h{type} and $h{type} eq &quot;string&quot;; 
                print &quot;------&quot; if $h{type} and $h{type} eq &quot;separator&quot;; 
                print &quot;UNKNOWN&quot; if not $h{type};
                print &quot;\n&quot;;
                
                my $submenu = GetSubMenu($menu, $i);
                if ($submenu) {
                        menu_parse($submenu, $depth+1);
                }
        }
    }
    
    
    SendKeys(&quot;%{F4}&quot;);</pre>
<p>
</p>
<h2><a name="eg/notepad.pl">eg/notepad.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: notepad.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    #
    
    use Win32::GuiTest;
    
    system(&quot;start notepad.exe&quot;);
    sleep 3;
    Win32::GuiTest::SendKeys(&quot;If you're reading this inside notepad,\n&quot;);
    Win32::GuiTest::SendKeys(&quot;we might consider this test succesful.\n&quot;);
    Win32::GuiTest::SendKeys(&quot;Now I'll send notepad an ALT{+}F4 to close\n&quot;);
    Win32::GuiTest::SendKeys(&quot;it. Please wait.......&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;.&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;.&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;.&quot;);
    Win32::GuiTest::SendKeys(&quot;%{F4}{TAB}{ENTER}&quot;);</pre>
<p>
</p>
<h2><a name="eg/notepad_text.pl">eg/notepad_text.pl</a></h2>
<pre>
    #!perl -w
    # $Id: notepad_text.pl,v 1.3 2004/07/21 17:47:38 szabgab Exp $
    # If you have a notepad window open this prints the contents.
    
    use strict;
    
    use Win32::GuiTest qw(FindWindowLike WMGetText);
    
    my @windows = FindWindowLike(0, &quot;&quot;, &quot;Notepad&quot;);
    die &quot;More than one notepad open\n&quot; if @windows &gt; 1;
    die &quot;No notepad is running, please open one with some text in it.\n&quot; if not @windows;
    
    my $notepad = $windows[0];
    my @edits = FindWindowLike($notepad, &quot;&quot;, &quot;Edit&quot;);
    die &quot;More than one edit inside notepad: &quot; .  @edits . &quot;\n&quot; if @edits &gt; 1;
    die &quot;No edit window found inside notepad\n&quot; if not @edits;
    
    print &quot;----------------------------------------------------------\n&quot;;
    print WMGetText($edits[0]);
    print &quot;\n&quot;;
    print &quot;----------------------------------------------------------\n&quot;;</pre>
<p>
</p>
<h2><a name="eg/paint.pl">eg/paint.pl</a></h2>
<pre>
    #!perl -w
    # $Id: paint.pl,v 1.3 2004/07/21 17:47:38 szabgab Exp $
    # Draw triangles in MS Paint.
    
    
    use strict;
    
    use Win32::GuiTest qw(:ALL); 
    
    system(&quot;start /max mspaint&quot;);
    sleep 2;
    my @windows = FindWindowLike(0, &quot;Paint&quot;, &quot;&quot;);
    die &quot;Could not find Paint\n&quot; if not @windows;
    
    
    SetForegroundWindow($windows[0]);
    sleep 1;
    
    # totaly guess work about the location of the area where one can draw.
    # A better guess would be welcome
    MouseMoveAbsPix((GetWindowRect($windows[0]))[0,1]);
    SendMouse ( &quot;{REL50,50}&quot; );  
    
    # Using high-level functions
    SendMouse ( &quot;{LEFTDOWN}&quot; );
    for (1..100) { SendMouse ( &quot;{REL1,1}&quot;  ); }
    for (1..100) { SendMouse ( &quot;{REL1,-1}&quot; ); }
    for (1..200) { SendMouse ( &quot;{REL-1,0}&quot; ); }
    SendMouse ( &quot;{LEFTUP}&quot; );
    
    
    
    # Using low level functions
    SendMouseMoveRel(5,20);
    SendLButtonDown();
    for (1..100) { SendMouseMoveRel(1,1);  }
    for (1..100) { SendMouseMoveRel(1,-1); }
    for (1..200) { SendMouseMoveRel(-1,0); }
    SendLButtonUp();</pre>
<p>
</p>
<h2><a name="eg/paint_abs.pl">eg/paint_abs.pl</a></h2>
<pre>
    #!perl -w
    # $Id: paint_abs.pl,v 1.3 2004/07/21 17:47:38 szabgab Exp $
    #
    # Draw an X and a box around it
    #
    use strict;
    use Win32::GuiTest qw(FindWindowLike SetForegroundWindow 
        SendMouse MouseMoveAbsPix SendLButtonDown SendLButtonUp);
    
    system(&quot;start /max mspaint&quot;);
    sleep 2;
    my @windows = FindWindowLike(0, &quot;Paint&quot;, &quot;&quot;);
    die &quot;Could not find Paint\n&quot; if not @windows;
    
    SetForegroundWindow($windows[0]);
    sleep 1;
    
    #Using low level functions
    MouseMoveAbsPix(100,100);
    SendLButtonDown();
    MouseMoveAbsPix(300,300);
    SendLButtonUp();
    
    
    sleep 1;
    
    MouseMoveAbsPix(100,300);
    SendLButtonDown();
    MouseMoveAbsPix(300,100);
    SendLButtonUp();
    
    sleep 1;
        
    MouseMoveAbsPix(100,100);
    SendLButtonDown();
    MouseMoveAbsPix(300,100);
    MouseMoveAbsPix(300,300);
    MouseMoveAbsPix(100,300);
    MouseMoveAbsPix(100,100);
    SendLButtonUp();</pre>
<p>
</p>
<h2><a name="eg/pushbutton.pl">eg/pushbutton.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: pushbutton.pl,v 1.4 2004/04/09 01:19:43 ctrondlp Exp $
    #
    
    use strict;
    use Win32::GuiTest qw(PushButton FindWindowLike SetForegroundWindow
        SendKeys WaitWindow IsWindow);
    
                                  
    # Test PushButton()
    
    # Remove old saved document
    unlink(&quot;C:\\temp\\PushButton.txt&quot;);
    
    system(&quot;start notepad.exe&quot;);
    my @windows = WaitWindow(&quot;Untitled - Notepad&quot;);
    #my @windows = WaitWindow(&quot; - Bloc de notas&quot;);
    die unless scalar @windows == 1 &amp;&amp; IsWindow($windows[0]);
    SetForegroundWindow($windows[0]);
    SendKeys(&quot;Sample Text\n&quot;);
    SendKeys(&quot;%{F4}&quot;);
    # Push Yes button to save document
    PushButton(&quot;Yes&quot;);
    #PushButton(&quot;Sí&quot;);
    # Type Filename
    SendKeys(&quot;C:\\temp\\PushButton.txt&quot;);
    # Push &amp;Save to save and exit
    PushButton(&quot;&amp;Save&quot;);
    #PushButton(&quot;&amp;Guardar&quot;);</pre>
<p>
</p>
<h2><a name="eg/rawkey.pl">eg/rawkey.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: rawkey.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    #
    
    use Win32::GuiTest qw(:FUNC :VK);
    
    while (1) {
        SendRawKey(VK_DOWN, KEYEVENTF_EXTENDEDKEY); 
        SendKeys &quot;{PAUSE 200}&quot;;
    }</pre>
<p>
</p>
<h2><a name="eg/selecttabitem.pl">eg/selecttabitem.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: selecttabitem.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    #
    
    use Win32::GuiTest qw(GetWindowID GetChildWindows GetWindowText
        GetForegroundWindow PostMessage PushButton SendKeys SelectTabItem);
    
    use Win32::GuiTest::Cmd qw(System);
    
    # Test 
    
    # Open System Properties
    # Tested on Win2k an NT4
    System();
    #system(&quot;start RunDLL32.exe shell32,Control_RunDLL sysdm.cpl,\@0,2&quot;);
    sleep(2);
    # Select various items on tab control
    # Using Window ID
    SelectTabItem(12320, 0);
    sleep(1);
    SelectTabItem(12320, 2);
    sleep(1);
    SelectTabItem(12320, 1);
    sleep(1);
    #PushButton(&quot;^Cancel&quot;);
    SendKeys(&quot;{ESC}&quot;);</pre>
<p>
</p>
<h2><a name="eg/showcpl.pl">eg/showcpl.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: showcpl.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    # Shows how to open control panel apps programmatically
    #
    
    use Win32::GuiTest::Cmd qw(
        Accessibility AppWizard Console DateTime
        Display Exchange Internet Joystick Modem
        Mouse Multimedia Network Odbc Pcmcia Ports Ras
        Regional Server System Telephony Ups Users);
    
    use Win32::GuiTest qw(SendKeys);
    
    Modem(); sleep 1;
    SendKeys(&quot;%{F4}&quot;);
    Network();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Console();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Accessibility();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    AppWizard();   sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Pcmcia();     sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Regional(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Joystick(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Mouse(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Multimedia(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Odbc(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Ports(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Server(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    System(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Telephony();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    DateTime();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Ups();sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Internet(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Display(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Ras(); sleep 1;
    SendKeys(&quot;%{F4}&quot;); 
    Users(); sleep 1;
    SendKeys(&quot;%{F4}&quot;);</pre>
<p>
</p>
<h2><a name="eg/showmouse.pl">eg/showmouse.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: showmouse.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    # This script has been written by Jarek Jurasz jurasz@imb.uni-karlsruhe.de
    
    use Win32::GuiTest qw(GetCursorPos);
    
    while (1)
    {
      ($x, $y) = GetCursorPos();
      print &quot;\rx:$x  y:$y   &quot;;
      sleep 1;
    }</pre>
<p>
</p>
<h2><a name="eg/showwin.pl">eg/showwin.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: showwin.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    # This script has been written by Jarek Jurasz jurasz@imb.uni-karlsruhe.de
    # selectively show/hide a group of windows
    # side effect: showing the window activates it
    
    use Win32::GuiTest qw(:ALL :SW);
    
    
    $name = shift;
    $show = shift;
    $class = undef;
    
    die &lt;&lt;EOT unless $name;
    Usage: $0 &quot;^Title&quot; [+1|-1]
    +1 show windows
    -1 hide windows
     0 or empty show status
    Be careful when using bare title words: when running the script, the title of 
    the console will change and include the title words, too...
    EOT
    
    
    # $name = &quot;^Microsoft Excel&quot; unless $name;
    my @win = FindWindowLike(0, $name, $class);
    
    showall(@win);
    
    sub showall
    {
      my @win = @_;
      for $win (@win)
      {
        # should normally be only one
        show($win);
        # children
        # showall(FindWindowLike($win, undef, undef));
      }
    }
    
    sub show
    {
      my $win = shift;
    
      # dumpwin($win);
      if ($show &gt; 0)
      {
        ShowWindow($win, SW_SHOW) unless (IsWindowVisible($win));
        # EnableWindow($win, 1);
      }
      elsif ($show &lt; 0)
      {
        ShowWindow($win, SW_HIDE) if (IsWindowVisible($win));
      }
      
      dumpwin($win);
    }
    
    sub dumpwin
    {
      my $win = shift;
      print &quot;Null handle\n&quot;, return unless ($win);
      print &quot;$win&gt;\tt:&quot;, GetWindowText($win), &quot; c:&quot;, GetClassName($win);
      print &quot; vis:&quot;, IsWindowVisible($win);
      print &quot; en:&quot;, IsWindowEnabled($win);
      print &quot;\n&quot;;
    }</pre>
<p>
</p>
<h2><a name="eg/spy.pl">eg/spy--.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: spy--.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    # MS has a very nice tool (Spy++).
    # This is Spy--
    #
    
    use Win32::GuiTest qw(FindWindowLike GetWindowText GetClassName
        GetChildDepth GetDesktopWindow);
    
    for (FindWindowLike()) {
        $s = sprintf(&quot;0x%08X&quot;, $_ );
        $s .= &quot;, '&quot; .  GetWindowText($_) . &quot;', &quot; . GetClassName($_);
        print &quot;+&quot; x GetChildDepth(GetDesktopWindow(), $_), $s, &quot;\n&quot;;
    }</pre>
<p>
</p>
<h2><a name="eg/spy.pl">eg/spy.pl</a></h2>
<pre>
    #!perl -w
    use strict;
    
    # Based on the spy--.pl within the distribution
    # Parse a subtree of the whole windoing systme and print as much information as possible
    # about each window and each object.
    # This software is in a very early stage. Its options and output format will change a lot.
    # Your input is welcome !
    
    # Written by Gabor Szabo &lt;gabor@pti.co.il&gt;
    
    # $Id: spy.pl,v 1.3 2004/07/21 21:38:22 szabgab Exp $
    my $VERSION = &quot;0.02&quot;;
    
    use Getopt::Long;
    use Win32::GuiTest qw(:ALL);
    my %opts;
    GetOptions(\%opts, &quot;help&quot;, &quot;title=s&quot;, &quot;all&quot;, &quot;id=i&quot;, &quot;class=s&quot;); 
    usage() if $opts{help} or not %opts;
    
    
    my %seen;
    my $desktop = GetDesktopWindow();
    my $root    = 0;
    my $start;
    
    $start = 0 if $opts{all};
    $start = $opts{id} if $opts{id};
    if ($opts{title} or $opts{class}) {
        my @windows = FindWindowLike(0, $opts{title}, $opts{class});
        #my @windows = FindWindowLike(0, $opts{title}) if $opts{title};
        #@windows = FindWindowLike(0, '', $opts{class}) if $opts{class};
        if (@windows &gt; 1) {
                print &quot;There are more than one window that fit:\n&quot;;
                foreach my $w (@windows) {
                        printf &quot;%s | %s | %s\n&quot;, $w,  GetClassName($w), GetWindowText($w);
                }
                exit;
        }
        die &quot;Did not find such a window.&quot; if not @windows;
        $start = $windows[0];
    }
    
    
    
    
    
    
    usage() if not defined $start;
    
    
    my $format = &quot;%-10s %-10s, '%-25s', %-10s, Rect:%-3s,%-3s,%-3s,%-3s   '%s'\n&quot;;
    printf $format,
                &quot;Depth&quot;,
                &quot;WindowID&quot;,
                &quot;ClassName&quot;,
                &quot;ParentID&quot;,
                &quot;WindowRect&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,
                &quot;WindowText&quot;;
    
    
    parse_tree($start);
    
    
    
    sub GetImmediateChildWindows {
        my $WinID = shift;
        grep {GetParent($_) eq $WinID} GetChildWindows $WinID;
    }
    
    sub parse_tree {
        my $w = shift;
        if ($seen{$w}++) {
                print &quot;loop $w\n&quot;;
                return;
        }
    
        prt($w);
        #foreach my $child (GetChildWindows($w)) {
        #       parse_tree($child);
        #}
        foreach my $child (GetImmediateChildWindows($w)) {
                print &quot;------------------\n&quot; if $w == 0;
                parse_tree($child);
        }
    }
    
    # GetChildDepth is broken so here is another version, this might work better.
     
    # returns the real distance between two windows
    # returns 0 if the same windows were provides
    # returns -1 if one of the values is not a valid window
    # returns -2 if the given &quot;ancestor&quot; is not really an ancestor of the given &quot;descendant&quot;
    sub MyGetChildDepth {
        my ($ancestor, $descendant) = @_;
        return -1 if $ancestor and (not IsWindow($ancestor) or not IsWindow($descendant));
        return 0 if $ancestor == $descendant;
        my $depth = 0;
        while ($descendant = GetParent($descendant)) {
                $depth++;
                last if $ancestor == $descendant;
        }
        return $depth + 1 if $ancestor == 0;
    }
    
    
    sub prt {
        my $w = shift;
        my $depth = MyGetChildDepth($root, $w);
        printf $format,
                (0 &lt;= $depth ? &quot;+&quot; x $depth : $depth),
                $w, 
                ($w ? GetClassName($w) : &quot;&quot;),
                ($w ? GetParent($w) : &quot;n/a&quot;),
                ($w ? GetWindowRect($w) : (&quot;n/a&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)),
                ($w ? GetWindowText($w) : &quot;&quot;); 
    }
    
    
    
    sub usage {
        print &quot;Version: v$VERSION\n&quot;;
        print &quot;Usage:\n&quot;;
        print &quot;        $0 --help\n&quot;;
        print &quot;        $0 --all\n&quot;;
        print &quot;        $0 --title TITLE\n&quot;;
        print &quot;\n&quot;;
        print &quot;As the output is quite verbose, probably you'll want to redirect \n&quot;;
        print &quot;the output to a file:   $0 options &gt; out.txt\n&quot;;
        print &quot;\n&quot;;
        exit;
    }</pre>
<p>
</p>
<h2><a name="eg/start.pl">eg/start.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: start.pl,v 1.1 2004/07/13 21:52:26 szabgab Exp $
    
    # Disclaimer: I tried this on my WindowsXP,
    # Other Windows, or other configurations might place the &quot;Run&quot; option
    # of the &quot;Start&quot; menu in different place so before running this script
    # make sure that your version of Windows will bring you to the &quot;Run&quot; option
    # if you press the left windows key and then the Up key 3 times.
    
    # Written by Gabor Szabo &lt;gabor@pti.co.il&gt;
    
    use Win32::GuiTest;
    
    # open the Start menu by pressing the Left Windows Key 
    # and then close it by hitting ESC.
    Win32::GuiTest::SendKeys(&quot;{LWI}&quot;);
    sleep 2;
    Win32::GuiTest::SendKeys(&quot;{ESC}&quot;);
    
    # Check out the version of your perl by opening a cmd.exe and typing perl -v
    # the sleep 1; lines were added only so the viewer can observe the process
    # you could actually send all the keys in one SendKeys call.
    
    Win32::GuiTest::SendKeys(&quot;{LWI}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{UP}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{UP}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{UP}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{ENTER}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;cmd{ENTER}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;perl -v&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{ENTER}&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;exit&quot;);
    sleep 1;
    Win32::GuiTest::SendKeys(&quot;{ENTER}&quot;);</pre>
<p>
</p>
<h2><a name="eg/tab.pl">eg/tab.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: tab.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    #
    
    use Win32::GuiTest qw(:FUNC :VK);
    
    SendRawKey(VK_MENU, 0);
    SendKeys(&quot;{TAB}{PAU 1000}{TAB}{PAU 1000}{TAB}&quot;);
    SendRawKey(VK_MENU, KEYEVENTF_KEYUP);</pre>
<p>
</p>
<h2><a name="eg/waitwindow.pl">eg/waitwindow.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: waitwindow.pl,v 1.3 2004/03/21 08:21:28 ctrondlp Exp $
    # Slightly modified from version submitted by anonymous contributor.
    #
    
    use strict;
    use Win32::GuiTest qw(IsWindow FindWindowLike SendKeys
        PushButton WaitWindow); 
    
    
    # Test WaitWindow()
    
    # en i18n constants 
    sub SOL  { &quot;^Solitaire&quot; }
    sub GAME { &quot;%G&quot; }
    sub OPT  { &quot;O&quot; }
    sub OPTIONS { &quot;^Options&quot; }
    sub CANCEL  { &quot;Cancel&quot; }
    
    # es i18n constants 
    #sub SOL  { &quot;^Solitario&quot; }
    #sub GAME { &quot;%J&quot; }
    #sub OPT  { &quot;O&quot; }
    #sub OPTIONS { &quot;^Opciones&quot; }
    #sub CANCEL  { &quot;Cancelar&quot; }
    
    # Open program
    system(&quot;start sol.exe&quot;);
    # Wait for program window to appear.
    die &quot;Couldn't open solitaire program!\n&quot;
        unless WaitWindow(SOL);
    # Select game menu
    SendKeys(GAME);
    # Open options menu
    SendKeys(OPT); 
    # Wait for options menu to appear for up to 5 seconds.
    WaitWindow(OPTIONS, 5);
    # Close options menu
    PushButton(CANCEL);
    # Close program
    SendKeys(&quot;%{F4}&quot;);</pre>
<p>
</p>
<h2><a name="eg/which.pl">eg/which.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: which.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    # Similar to UNIX which command.
    #
    # On my NT box:
    # 
    #  D:\src\perl\win32-guitest&gt;eg\which.pl perl
    #  D:\perl\bin\perl.EXE
    #  D:\src\perl\win32-guitest&gt;eg\which.pl regedit
    #  C:\WINNT\regedit.EXE
    #  D:\src\perl\win32-guitest&gt;eg\which.pl notepad
    #  C:\WINNT\system32\notepad.EXE
    #  D:\src\perl\win32-guitest&gt;
    #
    
    use strict;
    use Win32::GuiTest::Cmd qw(WhichExe);
    print WhichExe(shift);</pre>
<p>
</p>
<h2><a name="eg/winbmp.pl">eg/winbmp.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: winbmp.pl,v 1.2 2004/03/21 08:05:06 ctrondlp Exp $
    # This script has been written by Jarek Jurasz jurasz@imb.uni-karlsruhe.de
    # Save a given window as BMP file
    # Copy the contents to the clipboard
    
    
    use Win32::GuiTest qw(:ALL);
    
    ($w) = FindWindowLike(0, &quot;^Calc&quot;);
    $w = GetDesktopWindow unless $w;
    
    $ds = new Win32::GuiTest::DibSect;
    $ds-&gt;CopyWindow($w);
    #$ds-&gt;CopyClient(GetDesktopWindow(), \@{[GetWindowRect($w)]});
    # $ds-&gt;Invert();
    #$ds-&gt;CopyClient(GetDesktopWindow(), \@{[GetWindowRect($w)]});
    # $ds-&gt;Invert();
    #$ds-&gt;ToGrayScale();
    $ds-&gt;SaveAs(&quot;bla.bmp&quot;);
    $ds-&gt;ToClipboard();</pre>
<p>
</p>
<h2><a name="eg/wptr.pl">eg/wptr.pl</a></h2>
<pre>
    #!/usr/bin/perl
    # $Id: wptr.pl,v 1.4 2004/07/22 22:25:13 ctrondlp Exp $
    #
    
    # Module Pragmas
    use strict;
    use warnings;
    
    # Module Imports
    use Win32::GuiTest qw(GetCursorPos GetClassName GetWindowText
        GetWindowRect WindowFromPoint GetWindowID IsKeyPressed WMGetText);
    use Win32::Clipboard;
    
    # Module Level Variables
    my $Clip = Win32::Clipboard();
    my $cur_info = &quot;&quot;;
    my $oldhwnd = 0;
    my $oldcx = 0;
    my $oldcy = 0;
    
    # Core Loop
    while (1) {
        my ($cx, $cy) = GetCursorPos();
        # Is different cursor position?
        if ( ($cx != $oldcx) || ($cy != $oldcy) ) {
                $oldcx = $cx;
                $oldcy = $cy;
                # Get handle of window
                my $hwnd = WindowFromPoint($cx, $cy);
                if ($hwnd == $oldhwnd) {
                        # Same window as before, don't query information again.
                        next;
                }
                # Different window, so cache the handle value.
                $oldhwnd = $hwnd;
                # Get information for the new window in which the cursor is over.
                $cur_info = GetWindowInfo($hwnd);
                ClearScreen();
                # Output window information to console.
                DispWindowInfo($cur_info);
                # Display menu.
                DispMenu();
        }
        # INSERT to copy window data to clipboard.
        if (IsKeyPressed(&quot;INS&quot;)) {
                $Clip-&gt;Empty();
                $Clip-&gt;Set($cur_info);
                select(undef, undef, undef, 0.50);
                print &quot;Copied data to clipboard.\n&quot;;
        }
        # ESCAPE to exit this program.
        if (IsKeyPressed(&quot;ESC&quot;)) {
                print &quot;Goodbye!\n&quot;;
                last;
        }
    }
    
    
    sub ClearScreen {
        system(&quot;command /c cls&quot;);
        return;
    }
    
    sub GetWindowInfo {
        my $hwnd = shift;
        my $info =              &quot;# Window Text: '&quot; . GetWindowText($hwnd) . &quot;'\r\n&quot;;
        $info = $info . &quot;# Window Class: '&quot; . GetClassName($hwnd) . &quot;'\r\n&quot;;
        $info = $info . &quot;# Window ID: &quot; . GetWindowID($hwnd) . &quot;\r\n&quot;;
        my ($left, $top, $right, $bottom) = GetWindowRect($hwnd);
        $info = $info . &quot;# Window Rect: ($left, $top) - ($right, $bottom)\r\n&quot;;
    print &quot;Text: &quot; . WMGetText($hwnd) . &quot;\r\n&quot;;
        return($info);
    }
    
    sub DispWindowInfo {
        print shift;
        return;
    }
    
    sub DispMenu {
        print &quot;\n\nPress &lt;INSERT&gt; to copy window text to clipboard.\n&quot;;
        print &quot;Press &lt;ESCAPE&gt; to exit program.\n&quot;;
        return;
    }</pre>

</body>

</html>
